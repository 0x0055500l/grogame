<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Mini Grow Cube 3D</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; background: #222; }
        #ui {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            z-index: 10;
        }
        button {
            background: #fff;
            border: 2px solid #333;
            padding: 15px 30px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            margin: 0 10px;
            border-radius: 10px;
            transition: 0.2s;
        }
        button:hover { transform: scale(1.1); background: #f0f0f0; }
        button:disabled { background: #555; color: #888; cursor: not-allowed; transform: scale(1); }
        #status {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: white;
            font-size: 24px;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="status">Elige un elemento para empezar</div>
    
    <div id="ui">
        <button id="btnMountain" onclick="playTurn('mountain')">üèîÔ∏è Monta√±a</button>
        <button id="btnWater" onclick="playTurn('water')">üíß Agua</button>
        <button id="btnPlant" onclick="playTurn('plant')">üå≥ Planta</button>
        <button onclick="location.reload()" style="background:#ffaaaa">üîÑ Reiniciar</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>

    <script>
        // --- 1. CONFIGURACI√ìN DE ESCENA ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xeeeeee);

        // C√°mara isom√©trica para el estilo cl√°sico GROW
        const aspect = window.innerWidth / window.innerHeight;
        const d = 10;
        const camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
        camera.position.set(20, 20, 20);
        camera.lookAt(scene.position);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Luces
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // --- 2. OBJETOS DEL MUNDO (Inicialmente ocultos) ---
        
        // El Cubo Base
        const baseGeo = new THREE.BoxGeometry(8, 2, 8);
        const baseMat = new THREE.MeshLambertMaterial({ color: 0xcccccc });
        const base = new THREE.Mesh(baseGeo, baseMat);
        base.receiveShadow = true;
        scene.add(base);

        // Grupo Monta√±a
        const mountainGroup = new THREE.Group();
        const mGeo = new THREE.ConeGeometry(2, 4, 4);
        const mMat = new THREE.MeshLambertMaterial({ color: 0x888888 });
        const mountain = new THREE.Mesh(mGeo, mMat);
        mountain.position.y = 2; // Encima de la base
        mountainGroup.add(mountain);
        mountainGroup.position.set(-2, 1, -2);
        mountainGroup.visible = false; // Oculto
        scene.add(mountainGroup);

        // Grupo Agua (R√≠o)
        const waterGroup = new THREE.Group();
        const wGeo = new THREE.BoxGeometry(8.2, 1, 2); // Un canal
        const wMat = new THREE.MeshLambertMaterial({ color: 0x00aaff });
        const water = new THREE.Mesh(wGeo, wMat);
        water.position.y = 0;
        waterGroup.add(water);
        waterGroup.visible = false;
        scene.add(waterGroup);

        // Grupo Planta
        const plantGroup = new THREE.Group();
        // Tronco
        const trunkGeo = new THREE.CylinderGeometry(0.2, 0.2, 1, 8);
        const trunkMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
        const trunk = new THREE.Mesh(trunkGeo, trunkMat);
        // Hojas
        const leavesGeo = new THREE.DodecahedronGeometry(0.8);
        const leavesMat = new THREE.MeshLambertMaterial({ color: 0x22aa22 });
        const leaves = new THREE.Mesh(leavesGeo, leavesMat);
        leaves.position.y = 0.8;
        
        plantGroup.add(trunk, leaves);
        plantGroup.position.set(2, 1.5, 2); // En una esquina
        plantGroup.visible = false;
        scene.add(plantGroup);

        // --- 3. L√ìGICA GROW ---
        
        let turn = 0;
        // Estado actual de los elementos (0 = no existe, 1 = nivel 1, 2 = nivel max)
        let levels = { mountain: 0, water: 0, plant: 0 };
        let history = []; // Orden en que se seleccionaron

        function playTurn(type) {
            // Desactivar bot√≥n
            const btn = document.getElementById('btn' + type.charAt(0).toUpperCase() + type.slice(1));
            btn.disabled = true;
            history.push(type);
            turn++;

            // 1. Activar el elemento seleccionado (Nivel 1)
            levels[type] = 1;
            document.getElementById('status').innerText = `Turno ${turn}: A√±adiste ${type}`;

            // 2. Calcular evoluciones (Aqu√≠ est√° la magia del GROW)
            calculateGrowLogic();

            // 3. Actualizar gr√°ficos
            updateVisuals();
        }

        function calculateGrowLogic() {
            // REGLA 1: Todo lo que ya existe sube de nivel (simula paso del tiempo)
            // Pero en GROW real, solo suben si cumplen condiciones.
            
            // L√≥gica simplificada para este demo:
            
            // SI hay agua, la planta crece a Nivel 2
            if (levels.plant > 0 && levels.water > 0) {
                levels.plant = 2;
            }

            // SI hay monta√±a y agua, el agua se convierte en cascada (Nivel 2)
            // (Simplificado: Cambiamos color o forma)
            if (levels.mountain > 0 && levels.water > 0) {
                levels.water = 2;
            }
            
            // SI la planta es nivel 2 (√°rbol grande) y hay monta√±a, la monta√±a se vuelve verde (Nivel 2)
            if (levels.plant === 2 && levels.mountain > 0) {
                levels.mountain = 2;
            }
        }

        function updateVisuals() {
            // Animaciones usando GSAP para suavidad
            
            // --- MONTA√ëA ---
            if (levels.mountain === 1) {
                mountainGroup.visible = true;
                gsap.to(mountainGroup.scale, { x: 1, y: 1, z: 1, duration: 0.5 });
            } 
            if (levels.mountain === 2) {
                // La monta√±a "evoluciona" (se hace m√°s grande y verde)
                gsap.to(mountainGroup.scale, { x: 1.5, y: 1.5, z: 1.5, duration: 0.5 });
                mountain.material.color.setHex(0x44aa44); // Se vuelve verde
            }

            // --- AGUA ---
            if (levels.water === 1) {
                waterGroup.visible = true;
                gsap.to(waterGroup.scale, { x: 1, y: 1, z: 1, duration: 0.5 });
            }
            if (levels.water === 2) {
                // El agua brilla m√°s o cambia
                water.material.color.setHex(0x00ffff);
                gsap.to(water.scale, { x: 1, y: 1.2, z: 1, duration: 0.5 });
            }

            // --- PLANTA ---
            if (levels.plant === 1) {
                plantGroup.visible = true;
                gsap.to(plantGroup.scale, { x: 1, y: 1, z: 1, duration: 0.5 });
            }
            if (levels.plant === 2) {
                // √Årbol Gigante
                gsap.to(plantGroup.scale, { x: 2.5, y: 2.5, z: 2.5, duration: 0.8, ease: "bounce.out" });
            }
        }

        // Configuraci√≥n inicial de escalas a 0 para efecto "pop"
        mountainGroup.scale.set(0,0,0);
        waterGroup.scale.set(0,0,0);
        plantGroup.scale.set(0,0,0);

        // Bucle de renderizado
        function animate() {
            requestAnimationFrame(animate);
            
            // Rotaci√≥n suave de la escena completa para ver en 3D
            scene.rotation.y += 0.002;

            renderer.render(scene, camera);
        }
        animate();

        // Resize
        window.addEventListener('resize', () => {
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = -d * aspect;
            camera.right = d * aspect;
            camera.top = d;
            camera.bottom = -d;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>